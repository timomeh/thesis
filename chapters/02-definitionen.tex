%!TEX root = ../thesis.tex
\chapter{Deployment – Der Weg vom Entwickler zum Nutzer}

Theoretischer Teil der Arbeit. Er soll die Grundlagen des Themas der Arbeit klären, auf denen der danach folgende praktische Teil aufbaut.


\section{Definitionen und Begriffserklärungen}

Folgende Begriffe sind Grundlagen zum Verständnis der Arbeit.

\subsection{Definition: DevOps}

Auch wenn der Begriff DevOps nicht viel Verwendung in dieser Arbeit finden wird\footnote{Der Begriff DevOps beschreibt ein weitgreifendes Konzept, wird aber leider auch oft falsch verstanden und falsch verwendet. Daher wird in dieser Arbeit die Verwendung spezifischerer Begriffe bevorzugt.}, so sollte er auch nicht verschwiegen werden, da er stark mit der Thematik zusammenhängt.

DevOps setzt sich aus zwei englischsprachigen Wörtern zusammen: Development und Operations. Zu deutsch also die Verbindung von Entwicklung und Systembetrieb.

DevOps ist \emph{keine} Berufsgruppe wie oft fälschlicherweise angenommen, sondern eine Philosophie, die Entwicklung und Systembetrieb stärker miteinander verbindet. Im weiteren Sinne ist DevOps die Weiterführung agiler Entwicklungmethoden auf technischer Basis: Bei der agilen Entwicklung wird die Zusammenarbeit und Flexibilität zwischen Entwicklern und Unternehmen so verbessert, dass auf neue Anforderungen schneller eingegangen werden kann, damit jene schneller veröffentlicht werden (``Business Agility''). DevOps ergibt sich daraus, dass auch die Zusammenarbeit zwischen Entwicklern und IT Administratoren verbessert wird (``IT Agility''). \citep[4f]{Chapman2014}

Demnach ist ein großer Aspekt von DevOps die Verwendung automatisierter Prozesse zum schnellen und zuverlässigen Deployment von Anwendungen.

\subsection{Definition: Deployment}

Unter \emph{Deployment} (zu deutsch etwa ``Inbetriebsetzung'') versteht man in der Software-Entwicklung alle notwendigen Schritte, um ein System verwendbar zu machen (vgl. \citep[21]{Breuer2009}). Ein häufiger Anwendungsfall in der Praxis ist der Transfer und die Ausführung einer Applikation auf eine Zielumgebung, bspw. einem Produktions-Server.

\subsection{Definition und Anforderungen der Automatisierung}

Der Duden \citeyearpar{Duden} definiert \emph{automatisiert} u.a. als ``durch Selbststeuerung oder -regelung erfolgend''. Spezifischer für Software beschreibt \citet[27]{Duvall2007} einen Vorgang als automatisiert, wenn nach seinem Start kein weiteres menschliches Eingreifen mehr benötigt wird. Demnach handelt es sich bei einem \emph{automatisierten Deployment} um die Inbetriebssetzung einer Software ohne menschliches Handeln nach initialem Auslöser.

Im Gegensatz dazu steht die \emph{manuelle Durchführung} eines Prozesses. Im Kontext des Deployments müssen dabei einige oder gar alle Schritte zur Inbetriebssetzung durch menschliches Handeln durchgeführt werden.


Dies bedeutet jedoch nicht, dass ein automatisierter Prozess für den Nutzer gänzlich unsichtbar ist. Um auf Erfolg oder Fehlschlag des Automatismus reagieren zu können, muss der Prozess seinen Status an den Nutzer zurück melden. Vorteilhaft sind auch Informationen während des Prozessablaufs, beispielsweise um dessen Fortschritt zu verfolgen. \citep[10f]{Duvall2007}

\subsection{Definition von Webanwendung}

Software, die auf einem Server ausgeführt wird. Sie wird vom Nutzer (Client) über eine Schnittstelle, überlicherweise \ac{HTTP}, aufgerufen und die Ausgabe an ihn zurückgeschickt. Webanwendungen werden meist über einen Browser aufgerufen und müssen vom Nutzer nicht installiert werden.


\subsection{Definition und Eingrenzung: Tests und Builds}

Der Build ist quasi schon ein Test: ob die Software buildbar ist, was Anforderung ist, damit die Software überhaupt ausgeführt werden kann. Tests testen das Programm weiter auf die Richtigkeit von Funktionalitäten auch zur Laufzeit, zur Vermeidung von Bugs oder Abstürzen.

\textbf{Komponententest.} (Unit testing) Testen kleinster Einheiten.

\textbf{Integrationstest.} (Integration testing) Testet voneinander abhängige Komponenten. Abfolge von mehreren Schritten.

\textbf{Systemtest.} (System testing) Test auf alle funktionale und nichtfunktionale Anforderungen.

\textbf{Akzeptanztest.} (Acceptance testing) Verhalten der Software wird getestet, in Produktivumgebung, durch Kunden, wie der Kunde bzw. Nutzer die Software verwenden würde.

\textbf{Rauchtest.} (Smoke testing) Anwendung starten und testen, ob sie auch wirklich läuft oder direkt abgestürzt ist. Genannt, weil es ein sehr einfacher Test ist, der direkt nach dem Start der Anwendung getestet werden kann.


\section{Strukturierte Arbeitsabläufe mit automatisierten Deployments}

Bei der Entwicklung von Software in Teams ist es wichtig, dass man strukturiert vorgeht.

\subsection{Continuous Integration}

Änderungen am Code ständig testen. Mindestens einmal am Tag muss jeder in den master mergen. Master muss immer buildbar sein. Wenn nicht: direkt fixen oder revert.

\subsection{Continuous Delivery}

Erweiterung von Continuous Integration. Nach automatisiertem Test/Build auch automatisiert shippen können. Egal welche Zielumgebung/Server, alles automatisch konfiguriert. Je nach Anwendungsfall kann davor auch ein Server automatisch provisioniert werden. Wann deployed wird, kann selbst entschieden werden.

Siehe Agile Manifesto\footnote{http://agilemanifesto.org/principles.html}:

\begin{quote}
  Our highest priority is to satisfy the customer through early and \emph{continuous delivery} of valuable software.
\end{quote}


\subsection{Continuous Deployment}

Erweiterung von Continuous Delivery. Deployed wird ständig.


\section{Die Deployment-Pipeline als Prozess-Manifestation}
