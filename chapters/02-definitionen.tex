%!TEX root = ../thesis.tex
\chapter{Deployment – Der Weg vom Entwickler zum Nutzer}

{\draft
Theoretischer Teil der Arbeit. Er soll die Grundlagen des Themas der Arbeit klären, auf denen der danach folgende praktische Teil aufbaut.
}

\section{Definitionen und Begriffserklärungen}

Dieser Abschnitt soll vorweg jene Begriffe und deren Zusammenhang erklären, die zum Verständnis der Arbeit notwendig sind; vor allem die Begriffe \emph{Deployment}, \emph{automatisiert} und \emph{Webanwendung} aus dem Titel der Arbeit.

\subsection{Definition: Deployment}

Unter \emph{Deployment} (zu deutsch etwa ``Inbetriebsetzung'') versteht man in der Software-Entwicklung alle notwendigen Schritte, um ein System verwendbar zu machen \citep[21]{Breuer2009}. Dies beinhaltet u.a. das Ausführen von Tests, das kompilieren von ausführbaren Dateien oder anderen Artefakten, und dem Transfer auf eine Zielumgebung \citep[4]{Humble2010}.

Beim Deployment einer Webanwendungen sind jene Schritte beispielsweise:

\begin{itemize}
  \item Ausführen der Tests des Clients und des Servers
  \item Kompilieren von Artefakten wie CSS- und JavaScript-Dateien
  \item Transfer auf einen Server
  \item Ausführen eines Rauchtests
\end{itemize}

\subsection{Definition: Automatisierung}

Der Duden \citeyearpar{Duden} definiert \emph{automatisiert} u.a. als ``durch Selbststeuerung oder -regelung erfolgend''. Spezifischer für Software beschreibt \citet[27]{Duvall2007} einen Vorgang als automatisiert, wenn nach seinem Start kein weiteres menschliches Eingreifen mehr benötigt wird. Demnach handelt es sich bei einem \emph{automatisierten Deployment} um die Inbetriebsetzung einer Software ohne menschliches Handeln nach initialem Auslöser.

Im Gegensatz dazu steht die \emph{manuelle Durchführung} eines Prozesses. Im Kontext des Deployments müssen dabei einige oder gar alle Schritte zur Inbetriebsetzung durch menschliches Handeln durchgeführt werden.

Dies bedeutet jedoch nicht, dass ein automatisierter Prozess für den Nutzer gänzlich unsichtbar ist. Um auf Erfolg oder Fehlschlag des Automatismus reagieren zu können, muss der Prozess seinen Status an den Nutzer zurück melden. Vorteilhaft sind auch Informationen während des Prozessablaufs, beispielsweise um dessen Fortschritt zu verfolgen. \citep[10f]{Duvall2007}

\subsection{Begriffserklärung: DevOps}

Auch wenn der Begriff DevOps nicht viel Verwendung in dieser Arbeit finden wird\footnote{Der Begriff DevOps beschreibt ein weitgreifendes Konzept mit mehreren Aspekten. Daher wird in dieser Arbeit die Verwendung spezifischerer Begriffe bevorzugt.}, so sollte er auch nicht verschwiegen werden, da er stark mit der Thematik in Verbindung steht.

DevOps setzt sich aus den zwei englischsprachigen Wörtern \emph{Development} und \emph{Operations} zusammen. Zu deutsch also die Verbindung von Entwicklung und Systembetrieb. DevOps ist \emph{keine} Berufsgruppe, wie oft fälschlicherweise angenommen wird, sondern eine Kultur, die Entwicklung und Systembetrieb stärker miteinander verbindet.

Im weiteren Sinne ist DevOps die Weiterführung agiler Entwicklungsmethoden auf technischer Basis: Bei der agilen Entwicklung wird die Zusammenarbeit und Flexibilität zwischen Entwicklern und Unternehmen so verbessert, dass auf neue Anforderungen direkt eingegangen werden kann, damit jene schneller veröffentlicht werden (``Business Agility''). DevOps ergibt sich daraus, dass auch die Zusammenarbeit zwischen Entwicklern und IT Administratoren verbessert wird (``IT Agility''). \citep[4f]{Chapman2014}

Demnach ist ein Aspekt von DevOps die Verwendung automatisierter Prozesse zum schnellen und zuverlässigen Deployment von Anwendungen.

\subsection{Definition: Webanwendung}

\marginnote{Notiz: Bin mir unsicher, ob ich so einen Begriff wie ``Webanwendung'' definieren mag/soll.}[1em]

Eine Anwendung, die auf einem entfernten Webserver ausgeführt wird und vom Nutzer über eine Schnittstelle, meist \ac{HTTP}, mittels eines Webbrowsers aufgerufen wird. Eine Webanwendung wird dazu passend in zwei Teile aufgeteilt: die Programmlogik als Server und die Darstellung im Webbrowser als Client.

Moderne Webanwendungen werden immer öfter als verteilte Systeme programmiert. Hierbei wird der Server über ein \ac{API} angesprochen – zu deutsch vereinfacht \emph{Schnittstelle} –, zu welcher der Client dynamisch mittels JavaScript eine grafische Repräsentation ausgibt.


\subsection{Definition und Eingrenzung: Build} \label{ssec02:build}

\citet[27]{Duvall2007} definiert den Begriff Build als ``a set of activities performed to generate, test, inspect and deploy software''. \emph{Build} wird hierbei als Prozess definiert, welcher in Kapitel \ref{sec02:deployment-pipeline} als \emph{Deployment-Pipeline} näher beleuchtet wird.

Ein Build kann auch als Ergebnis des Building-Vorgangs interpretiert werden, bei dem eine Software als kompilierte Binärdatei oder – abhängig von der Programmiersprache – auch als Quellcode inklusive generierter Artefakte erstellt wird. Ein solcher Build stellt die fertige Anwendung dar und wird meist mit einer eindeutigen Versionsnummer versehen, um ihn von früheren oder späteren Builds zu unterscheiden.

\subsection{Erklärung und Beispiele: Testing}

Tests überprüfen die Qualität und Anforderungen einer Anwendung. Tests, die automatisiert durchgeführt werden können, werden bereits vom Entwickler geschrieben und helfen dabei, Fehler frühzeitig zu erkennen und zu beheben. Hierzu gehören \emph{Komponententests} (engl. unit test), welche kleinste Einheiten der Anwendung überprüfen, und \emph{Integrationstests} (engl. integration test), die das Zusammenspiel verschiedener Komponenten testen. Ebenso ermöglichen jene Tests das fehlerfreie Umstrukturieren von Code (\emph{refactoring}). \citep[104f]{Wolff2016}

Eine weitere Art von Test ist der \emph{Akzeptanztest} (engl. acceptance test), bei dem die Funktionalität der Anwendung für den Nutzer überprüft wird. Diese können vom Kunden, einer \ac{QA} oder gar dem Nutzer durchgeführt werden. Akzeptanztests können automatisiert werden, werden oft aber auch manuell durchgeführt.

Der \emph{Rauchtest} (engl. smoke test) ist ein sehr einfach umzusetzender Test, bei dem die Software gestartet wird und danach überprüft wird, ob sie noch läuft oder abgestürzt ist. Bei Webanwendungen kann hierfür die Startseite aufgerufen werden und nach einer Zeichenkette gesucht werden, die dort auftauchen sollte.

Letztlich handelt es sich bei einem Build, wie in Kapitel \ref{ssec02:build} definiert, indirekt ebenfalls um einen Test. Ein Build kann fehlschlagen, was z.B. auf Syntaxfehler oder Abweichungen in der Systemumgebung hinweisen kann. Ein erfolgreicher Build gibt die Sicherheit, dass in diesen Aspekten keine Fehler vorhanden sind.


\section{Strukturierte Arbeitsabläufe mit automatisierten Deployments}

Sobald mehrere Entwickler an einem Projekt arbeiten, ist ein strukturierter Arbeitsablauf notwendig. Im Bezug auf automatisierte Deployments gibt es drei etablierte Verfahrensweisen, die aufeinander aufbauen: \emph{Continuous Integration}, \emph{Continuous Delivery} und \emph{Continuous Deployment}.

Auch ohne zu wissen, was hinter diesen Begriffen steckt, ist die Gemeinsamkeit \emph{``continuous''} erkennbar; zu Deutsch übersetzbar als \emph{kontinuierlich} oder – noch passender: \emph{ununterbrochen}. Wir können jetzt schon darauf schließen, dass in diesen Verfahrensweisen ständig etwas getan wird.

\subsection{Continuous Integration}

Neue oder geänderte Funktionalitäten einer Software können nur selten innerhalb weniger Stunden entwickelt werden. Manche Features benötigen mehrere Tage, Wochen oder gar Monate zur Fertigstellung. Wenn während\-dessen die Anwendung von anderen Entwicklern noch weiterentwickelt wird, kommt irgendwann der Zeitpunkt, an dem jene Änderungen \emph{integriert} werden müssen.

Nun besteht die Gefahr, dass die Integration der Änderungen in die mittlerweile veränderte Anwendung weiteren Aufwand mit sich bringt. Dieses Szenario soll durch \emph{Continuous Integration} verhindert werden.

\ac{CI} bedeutet die ununterbrochene Integration von Änderungen in die Anwendung. Ein Entwickler soll mindestens einmal am Tag seine Änderungen in den Hauptentwicklungszweig (Trunk) integrieren. Bei jeder Integration muss die Anwendung stabil bleiben, alle Tests müssen erfolgreich sein und die Anwendung muss buildbar sein. Sollte eine Integration fehlschlagen, muss sie entweder mit höchster Priorität innerhalb weniger Minuten behoben werden oder rückgängig gemacht werden.

Das Ergebnis von \ac{CI} ist ein Trunk, der zu jedem Zeitpunkt stabil ist und die neusten Änderungen der Software beinhaltet. Um \ac{CI} erfolgreich betreiben zu können und um den Aufwand für den Entwickler zu reduzieren, sollte das stetige Testen neuer Integrationen von einem Automatismus übernommen werden.


\subsection{Continuous Delivery}

Continuous Delivery ist die Weiterführung von Continuous Integration. Da der Trunk jederzeit durch einen Automatismus getestet wird, ist es danach auch möglich, den Transfer und die Ausführung der Anwendung, inklusive aller damit verbundenen Schritte, auf eine beliebige Zielumgebung automatisiert durchzuführen.

Nach der Integration muss nicht zwangsläufig ein automatisiertes Deployment erfolgen. Es soll nur möglich sein, die Anwendung ohne weiteren Aufwand automatisiert zu deployen. Dadurch kann beispielsweise ein Tester eigenständig eine bestimmte Version der Anwendung auf eine Testumgebung aufspielen, genauso wie auch ein neuer Release auf einem Produktionsserver ohne Aufwand aufgespielt werden kann.

Das Konzept des Continuous Delivery ist eng verbunden mit der agilen Arbeitsmethode:

\begin{quote}
  Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
\end{quote}

Da Continuous Delivery eng mit automatisiertem Deployment in Verbindung steht, werden oft beide Begriffe synonym verwendet.

\begin{draft}

Erweiterung von Continuous Integration. Nach automatisiertem Test/Build auch automatisiert shippen können. Egal welche Zielumgebung/Server, alles automatisch konfiguriert. Je nach Anwendungsfall kann davor auch ein Server automatisch provisioniert werden. Wann deployed wird, kann selbst entschieden werden.

Siehe Agile Manifesto\footnote{http://agilemanifesto.org/principles.html}:

\begin{quote}
  Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
\end{quote}


\subsection{Continuous Deployment}

Erweiterung von Continuous Delivery. Deployed wird ständig.


\section{Die Deployment-Pipeline als Prozess-Manifestation} \label{sec02:deployment-pipeline}
\end{draft}
