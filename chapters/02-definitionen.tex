%!TEX root = ../thesis.tex
\chapter{Deployment – Der Weg vom Entwickler zum Nutzer}

{\draft
Theoretischer Teil der Arbeit. Er soll die Grundlagen des Themas der Arbeit klären, auf denen der danach folgende praktische Teil aufbaut.
}

\section{Definitionen und Begriffserklärungen}

Dieser Abschnitt soll vorweg jene Begriffe und deren Zusammenhang erklären, die zum Verständnis der Arbeit notwendig sind; vor allem die Begriffe \emph{Deployment}, \emph{automatisiert} und \emph{Webanwendung} aus dem Titel der Arbeit.

\subsection{Definition: Deployment}

Unter \emph{Deployment} (zu deutsch etwa ``Inbetriebsetzung'') versteht man in der Software-Entwicklung alle notwendigen Schritte, um ein System verwendbar zu machen \citep[21]{Breuer2009}. Dies beinhaltet u.a. das Ausführen von Tests, das kompilieren von ausführbaren Dateien oder anderen Artefakten, und dem Transfer auf eine Zielumgebung \citep[4]{Humble2010}.

Beim Deployment einer Webanwendungen sind jene Schritte beispielsweise:

\begin{itemize}
  \item Ausführen der Tests des Clients und des Servers
  \item Kompilieren von Artefakten wie CSS- und JavaScript-Dateien
  \item Transfer auf einen Server
  \item Ausführen eines Rauchtests
\end{itemize}

\subsection{Definition: Automatisierung}

Der Duden \citeyearpar{Duden} definiert \emph{automatisiert} u.a. als ``durch Selbststeuerung oder -regelung erfolgend''. Spezifischer für Software beschreibt \citet[27]{Duvall2007} einen Vorgang als automatisiert, wenn nach seinem Start kein weiteres menschliches Eingreifen mehr benötigt wird. Demnach handelt es sich bei einem \emph{automatisierten Deployment} um die Inbetriebsetzung einer Software ohne menschliches Handeln nach initialem Auslöser.

Im Gegensatz dazu steht die \emph{manuelle Durchführung} eines Prozesses. Im Kontext des Deployments müssen dabei einige oder gar alle Schritte zur Inbetriebsetzung durch menschliches Handeln durchgeführt werden.

Dies bedeutet jedoch nicht, dass ein automatisierter Prozess für den Nutzer gänzlich unsichtbar ist. Um auf Erfolg oder Fehlschlag des Automatismus reagieren zu können, muss der Prozess seinen Status an den Nutzer zurück melden. Vorteilhaft sind auch Informationen während des Prozessablaufs, beispielsweise um dessen Fortschritt zu verfolgen. \citep[10f]{Duvall2007}

\subsection{Begriffserklärung: DevOps}

Auch wenn der Begriff DevOps nicht viel Verwendung in dieser Arbeit finden wird\footnote{Der Begriff DevOps beschreibt ein weitgreifendes Konzept mit mehreren Aspekten. Daher wird in dieser Arbeit die Verwendung spezifischerer Begriffe bevorzugt.}, so sollte er auch nicht verschwiegen werden, da er stark mit der Thematik in Verbindung steht.

DevOps setzt sich aus den zwei englischsprachigen Wörtern \emph{Development} und \emph{Operations} zusammen. Zu deutsch also die Verbindung von Entwicklung und Systembetrieb. DevOps ist \emph{keine} Berufsgruppe, wie oft fälschlicherweise angenommen wird, sondern eine Kultur, die Entwicklung und Systembetrieb stärker miteinander verbindet.

Im weiteren Sinne ist DevOps die Weiterführung agiler Entwicklungsmethoden auf technischer Basis: Bei der agilen Entwicklung wird die Zusammenarbeit und Flexibilität zwischen Entwicklern und Unternehmen so verbessert, dass auf neue Anforderungen direkt eingegangen werden kann, damit jene schneller veröffentlicht werden (``Business Agility''). DevOps ergibt sich daraus, dass auch die Zusammenarbeit zwischen Entwicklern und IT Administratoren verbessert wird (``IT Agility''). \citep[4f]{Chapman2014}

Demnach ist ein Aspekt von DevOps die Verwendung automatisierter Prozesse zum schnellen und zuverlässigen Deployment von Anwendungen.

\subsection{Definition: Webanwendung}

\marginnote{Notiz: Bin mir unsicher, ob ich so einen Begriff wie ``Webanwendung'' definieren mag/soll.}[1em]

Eine Anwendung, die auf einem entfernten Webserver ausgeführt wird und vom Nutzer über eine Schnittstelle, meist \ac{HTTP}, mittels eines Webbrowsers aufgerufen wird. Eine Webanwendung wird dazu passend in zwei Teile aufgeteilt: die Programmlogik als Server und die Darstellung im Webbrowser als Client.

Moderne Webanwendungen werden immer öfter als verteilte Systeme programmiert. Hierbei wird der Server über ein \ac{API} angesprochen – zu deutsch vereinfacht \emph{Schnittstelle} –, zu welcher der Client dynamisch mittels JavaScript eine grafische Repräsentation ausgibt.


\subsection{Definition und Eingrenzung: Build} \label{ssec02:build}

\citet[27]{Duvall2007} definiert den Begriff Build als ``a set of activities performed to generate, test, inspect and deploy software''. \emph{Build} wird hierbei als Prozess definiert, welcher in Kapitel \ref{sec02:deployment-pipeline} als \emph{Deployment-Pipeline} näher beleuchtet wird.

Ein Build kann auch als Ergebnis des Building-Vorgangs interpretiert werden, bei dem eine Software als kompilierte Binärdatei oder – abhängig von der Programmiersprache – auch als Quellcode inklusive generierter Artefakte erstellt wird. Ein solcher Build stellt die fertige Anwendung dar und wird meist mit einer eindeutigen Versionsnummer versehen, um ihn von früheren oder späteren Builds zu unterscheiden.

\subsection{Erklärung und Beispiele: Testing}

Tests überprüfen die Qualität und Anforderungen einer Anwendung. Tests, die automatisiert durchgeführt werden können, werden bereits vom Entwickler geschrieben und helfen dabei, Fehler frühzeitig zu erkennen und zu beheben. Hierzu gehören \emph{Komponententests} (engl. unit test), welche kleinste Einheiten der Anwendung überprüfen, und \emph{Integrationstests} (engl. integration test), die das Zusammenspiel verschiedener Komponenten testen. Ebenso ermöglichen jene Tests das fehlerfreie Umstrukturieren von Code (\emph{refactoring}). \citep[104f]{Wolff2016}

Eine weitere Art von Test ist der \emph{Akzeptanztest} (engl. acceptance test), bei dem die Funktionalität der Anwendung für den Nutzer überprüft wird. Diese können vom Kunden, einer \ac{QA} oder gar dem Nutzer durchgeführt werden. Akzeptanztests können automatisiert werden, werden oft aber auch manuell durchgeführt.

Der \emph{Rauchtest} (engl. smoke test) ist ein sehr einfach umzusetzender Test, bei dem die Software gestartet wird und danach überprüft wird, ob sie noch läuft oder abgestürzt ist. Bei Webanwendungen kann hierfür die Startseite aufgerufen werden und nach einer Zeichenkette gesucht werden, die dort auftauchen sollte.

Letztlich handelt es sich bei einem Build, wie in Kapitel \ref{ssec02:build} definiert, indirekt ebenfalls um einen Test. Ein Build kann fehlschlagen, was z.B. auf Syntaxfehler oder Abweichungen in der Systemumgebung hinweisen kann. Ein erfolgreicher Build gibt die Sicherheit, dass in diesen Aspekten keine Fehler vorhanden sind.


\section{Strukturierte Arbeitsabläufe mit automatisierten Deployments}

\begin{draft}
Bei der Entwicklung von Software in Teams ist es wichtig, dass man strukturiert vorgeht.

\subsection{Continuous Integration}

Änderungen am Code ständig testen. Mindestens einmal am Tag muss jeder in den master mergen. Master muss immer buildbar sein. Wenn nicht: direkt fixen oder revert.

\subsection{Continuous Delivery}

Erweiterung von Continuous Integration. Nach automatisiertem Test/Build auch automatisiert shippen können. Egal welche Zielumgebung/Server, alles automatisch konfiguriert. Je nach Anwendungsfall kann davor auch ein Server automatisch provisioniert werden. Wann deployed wird, kann selbst entschieden werden.

Siehe Agile Manifesto\footnote{http://agilemanifesto.org/principles.html}:

\begin{quote}
  Our highest priority is to satisfy the customer through early and \emph{continuous delivery} of valuable software.
\end{quote}


\subsection{Continuous Deployment}

Erweiterung von Continuous Delivery. Deployed wird ständig.


\section{Die Deployment-Pipeline als Prozess-Manifestation} \label{sec02:deployment-pipeline}
\end{draft}
